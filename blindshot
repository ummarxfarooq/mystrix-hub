local WindUI = loadstring(game:HttpGet("https://raw.githubusercontent.com/Footagesus/WindUI/main/dist/main.lua"))()
local Window = WindUI:CreateWindow({
    Title = "Mystrix Hub - Blind Shot",
    Icon = "app-window-mac",
    Author = "Ummarxfarooq",
    Theme = "Dark"
})

WindUI:AddTheme({
    Name = "RubyNoir",
    Accent = WindUI:Gradient({
        ["0"] = { Color = Color3.fromHex("#991B1B"), Transparency = 0 },
        ["100"] = { Color = Color3.fromHex("#7F1D1D"), Transparency = 0 }
    }, { Rotation = 45 }),
    Dialog = WindUI:Gradient({
        ["0"] = { Color = Color3.fromHex("#0A0303"), Transparency = 0 },
        ["100"] = { Color = Color3.fromHex("#120606"), Transparency = 0 }
    }, { Rotation = 90 }),
    Outline = Color3.fromHex("#DC2626"),
    Text = Color3.fromHex("#E5E5E5"),
    Placeholder = Color3.fromHex("#450A0A"),
    Background = WindUI:Gradient({
        ["0"] = { Color = Color3.fromHex("#000000"), Transparency = 0 },
        ["100"] = { Color = Color3.fromHex("#0D0404"), Transparency = 0 }
    }, { Rotation = 180 }),
    Button = WindUI:Gradient({
        ["0"] = { Color = Color3.fromHex("#7F1D1D"), Transparency = 0 },
        ["100"] = { Color = Color3.fromHex("#991B1B"), Transparency = 0 }
    }, { Rotation = 90 }),
    Icon = Color3.fromHex("#DC2626")
})
WindUI:SetTheme("RubyNoir")

local DiscordTab = Window:Tab({
    Title = "Discord",
    Icon = "geist:logo-discord",
    Opened = true
})
DiscordTab:Select()

local DiscordSection = DiscordTab:Section({
    Title = "Join Our Discord Server",
    Icon = "users",
    Opened = true
})

DiscordSection:Button({
    Title = "Copy Link",
    Desc = "Tap Here To Copy The Link To Join",
    Icon = "link",
    Callback = function()
        local inviteLink = "https://discord.gg/XV66VWqAaN"
        if setclipboard then
            setclipboard(inviteLink)
        end
    end
})

local KeybindSection = DiscordTab:Section({
    Title = "UI Keybind",
    Icon = "keyboard",
    Opened = true
})

KeybindSection:Keybind({
    Title = "Toggle UI",
    Desc = "Press to open/close the UI",
    Value = "J",
    Callback = function(v)
        Window:SetToggleKey(Enum.KeyCode[v])
    end
})


local WhatsNew = DiscordTab:Section({
    Title = "Important!",
    Icon = "message-circle-question-mark",
    Opened = true
})

WhatsNew:Paragraph({
    Title = "Note : ",
    Desc = "â€¢ This can have bugs if you find any, report to the discord server!",
    Color = "Red",
    Image = "",
    ImageSize = 30,
    Thumbnail = "",
    ThumbnailSize = 80,
    Locked = false,
    Buttons = {}
})


local MenuSection = Window:Section({
    Title = "Menu",
    Icon = "menu",
    Opened = true,
})

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

local espHighlights = {}
local espConnections = {}
local espEnabled = false
local trackedPlayers = {}
local transparencyConnections = {}
local beamESPConnections = {}
local beamESPEnabled = false
local trackedBeams = {}
local bombsESPEnabled = false
local turnESPEnabled = false

local colorMap = {
    ["Red"] = Color3.fromRGB(255, 0, 0),
    ["Blue"] = Color3.fromRGB(0, 0, 255),
    ["Green"] = Color3.fromRGB(0, 255, 0),
    ["Yellow"] = Color3.fromRGB(255, 255, 0),
    ["Black"] = Color3.fromRGB(0, 0, 0),
    ["Purple"] = Color3.fromRGB(128, 0, 128),
    ["Orange"] = Color3.fromRGB(255, 165, 0),
    ["Cyan"] = Color3.fromRGB(0, 255, 255),
    ["White"] = Color3.fromRGB(255, 255, 255)
}

local selectedESPColor = "Green"
local currentESPColor = Color3.fromRGB(0, 255, 0)
local espSizeMultiplier = 1
local tempSizeMultiplier = 1
local originalPartSizesESP = {}

local function findBeams()
    local beams = {}
    for _, playerModel in pairs(workspace:GetChildren()) do
        if playerModel:IsA("Model") then
            for _, skinModel in pairs(playerModel:GetChildren()) do
                if skinModel:IsA("Model") and skinModel.Name:match("^Skin_") then
                    local ponto = skinModel:FindFirstChild("ponto")
                    if ponto then
                        local beam = ponto:FindFirstChildOfClass("Beam")
                        if beam then
                            table.insert(beams, beam)
                        end
                    end
                end
            end
        end
    end
    return beams
end

local function maintainBeamEnabled(beam)
    if not beam or not beam:IsA("Beam") then return end
    if trackedBeams[beam] then return end
    trackedBeams[beam] = true
    
    local RunService = game:GetService("RunService")
    local connection = RunService.Heartbeat:Connect(function()
        if beam and beam.Parent and beamESPEnabled then
            if not beam.Enabled then
                beam.Enabled = true
            end
        else
            connection:Disconnect()
            trackedBeams[beam] = nil
        end
    end)
    
    table.insert(beamESPConnections, connection)
    
    local propertyConnection = beam:GetPropertyChangedSignal("Enabled"):Connect(function()
        if beamESPEnabled and not beam.Enabled then
            beam.Enabled = true
        end
    end)
    
    table.insert(beamESPConnections, propertyConnection)
end

local function enableAllBeams()
    local beams = findBeams()
    for _, beam in pairs(beams) do
        maintainBeamEnabled(beam)
    end
end

local function removeAllBeamESP()
    for _, connection in pairs(beamESPConnections) do
        if connection and typeof(connection) == "RBXScriptConnection" then
            pcall(function() connection:Disconnect() end)
        end
    end
    beamESPConnections = {}
    trackedBeams = {}
end

local function monitorForNewBeams()
    local descendantConnection = workspace.DescendantAdded:Connect(function(descendant)
        if beamESPEnabled and descendant:IsA("Beam") and descendant.Name == "Beam" then
            local parent = descendant.Parent
            if parent and parent.Name == "ponto" then
                local skinParent = parent.Parent
                if skinParent and skinParent.Name:match("^Skin_") then
                    task.wait(0.05)
                    maintainBeamEnabled(descendant)
                end
            end
        end
    end)
    table.insert(beamESPConnections, descendantConnection)
end

local function makeTransparent(object)
    if object and object:IsA("BasePart") then
        object.Transparency = 0
    end
    for _, child in pairs(object:GetDescendants()) do
        if child:IsA("BasePart") then
            child.Transparency = 0
        end
    end
end

local function enableBombsVisibility()
    while bombsESPEnabled do
        local bomb = workspace:FindFirstChild("Bomb")
        if bomb then
            makeTransparent(bomb)
        end
        local nuke = workspace:FindFirstChild("Nuke")
        if nuke then
            makeTransparent(nuke)
        end
        task.wait(0.05)
    end
end

local function enableBombsESP()
    task.spawn(enableBombsVisibility)
end

local function removeAllBombsESP()
end

local function isLocalPlayer(model)
    if not LocalPlayer.Character then return false end
    return model == LocalPlayer.Character or model.Name == LocalPlayer.Name
end

local function enableAllOrdemBillboards()
    while turnESPEnabled do
        for _, playerModel in pairs(workspace:GetChildren()) do
            if playerModel:IsA("Model") and not isLocalPlayer(playerModel) then
                local head = playerModel:FindFirstChild("Head")
                if head then
                    local ordemBillboard = head:FindFirstChild("OrdemBillboard")
                    if ordemBillboard then
                        ordemBillboard.Enabled = true
                    end
                end
            end
        end
        task.wait(0.05)
    end
end

local function enableTurnESP()
    task.spawn(enableAllOrdemBillboards)
end

local function removeAllTurnESP()
end

local function isValidPlayerCharacter(model)
    if not model:IsA("Model") then return false end
    if isLocalPlayer(model) then return false end
    if model.Name == "hitbox" then return false end
    local humanoid = model:FindFirstChildOfClass("Humanoid")
    local rootPart = model:FindFirstChild("HumanoidRootPart") or model:FindFirstChild("Torso") or model:FindFirstChild("UpperTorso")
    return humanoid ~= nil and rootPart ~= nil
end

local function maintainPartVisibility(model)
    if not model then return end
    if not transparencyConnections[model] then
        transparencyConnections[model] = {}
    end
    
    local function forcePartVisible(part)
        if not part:IsA("BasePart") then return end
        if part.Name:lower() == "hitbox" then return end
        
        local connection = part:GetPropertyChangedSignal("Transparency"):Connect(function()
            if part.Transparency > 0.9 and part.Name:lower() ~= "hitbox" then
                part.Transparency = 0
            end
        end)
        
        table.insert(transparencyConnections[model], connection)
        
        if part.Transparency > 0.9 and part.Name:lower() ~= "hitbox" then
            part.Transparency = 0
        end
    end
    
    for _, descendant in pairs(model:GetDescendants()) do
        forcePartVisible(descendant)
    end
    
    local descendantAddedConnection = model.DescendantAdded:Connect(function(descendant)
        forcePartVisible(descendant)
    end)
    
    table.insert(transparencyConnections[model], descendantAddedConnection)
    
    local RunService = game:GetService("RunService")
    local heartbeatConnection = RunService.Heartbeat:Connect(function()
        if model and model.Parent then
            for _, part in pairs(model:GetDescendants()) do
                if part:IsA("BasePart") and part.Transparency > 0.9 and part.Name:lower() ~= "hitbox" then
                    part.Transparency = 0
                end
            end
        else
            heartbeatConnection:Disconnect()
        end
    end)
    
    table.insert(transparencyConnections[model], heartbeatConnection)
end

local function storeOriginalSizesESP(model)
    if not model then return end
    originalPartSizesESP[model] = {}
    for _, part in pairs(model:GetDescendants()) do
        if part:IsA("BasePart") then
            originalPartSizesESP[model][part.Name] = part.Size
        end
    end
end

local function applyScaleESP(model)
    if not model or not originalPartSizesESP[model] then return end
    for _, part in pairs(model:GetDescendants()) do
        if part:IsA("BasePart") and originalPartSizesESP[model][part.Name] then
            part.Size = originalPartSizesESP[model][part.Name] * espSizeMultiplier
        end
    end
end

local function resetScaleESP(model)
    if not model or not originalPartSizesESP[model] then return end
    for _, part in pairs(model:GetDescendants()) do
        if part:IsA("BasePart") and originalPartSizesESP[model][part.Name] then
            part.Size = originalPartSizesESP[model][part.Name]
        end
    end
end

local function createESP(model)
    if not isValidPlayerCharacter(model) then
        return
    end
    
    if espHighlights[model] then
        pcall(function() espHighlights[model]:Destroy() end)
        espHighlights[model] = nil
    end
    
    local highlight = Instance.new("Highlight")
    highlight.Adornee = model
    highlight.FillColor = currentESPColor
    highlight.OutlineColor = currentESPColor
    highlight.FillTransparency = 0.5
    highlight.OutlineTransparency = 0
    highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    highlight.Parent = model
    
    espHighlights[model] = highlight
    maintainPartVisibility(model)
    storeOriginalSizesESP(model)
    applyScaleESP(model)
end

local function removeESP(model)
    resetScaleESP(model)
    
    if transparencyConnections[model] then
        for _, connection in pairs(transparencyConnections[model]) do
            pcall(function() connection:Disconnect() end)
        end
        transparencyConnections[model] = nil
    end
    
    if espHighlights[model] then
        pcall(function() espHighlights[model]:Destroy() end)
        espHighlights[model] = nil
    end
    originalPartSizesESP[model] = nil
end

local function removeAllESP()
    for model, highlight in pairs(espHighlights) do
        removeESP(model)
    end
    espHighlights = {}
    transparencyConnections = {}
    
    for _, connection in pairs(espConnections) do
        if connection and typeof(connection) == "RBXScriptConnection" then
            pcall(function() connection:Disconnect() end)
        end
    end
    espConnections = {}
    trackedPlayers = {}
end

local function setupPlayerESP(model)
    if not isValidPlayerCharacter(model) then
        return
    end
    createESP(model)
    trackedPlayers[model] = true
end

local function scanWorkspaceForPlayers()
    for _, child in pairs(workspace:GetChildren()) do
        if isValidPlayerCharacter(child) and not trackedPlayers[child] then
            setupPlayerESP(child)
        end
    end
end

local function applyESPToAll()
    scanWorkspaceForPlayers()
    
    local childAddedConnection = workspace.ChildAdded:Connect(function(child)
        if espEnabled then
            task.wait(0.5)
            if isValidPlayerCharacter(child) and not trackedPlayers[child] then
                setupPlayerESP(child)
            end
        end
    end)
    
    table.insert(espConnections, childAddedConnection)
    
    local childRemovedConnection = workspace.ChildRemoved:Connect(function(child)
        if trackedPlayers[child] then
            removeESP(child)
            trackedPlayers[child] = nil
        end
    end)
    
    table.insert(espConnections, childRemovedConnection)
end

local function updateESPColors()
    for model, highlight in pairs(espHighlights) do
        if highlight and highlight.Parent then
            highlight.FillColor = currentESPColor
            highlight.OutlineColor = currentESPColor
        end
    end
end

local function updateESPSize()
    if not espEnabled then
        espSizeMultiplier = tempSizeMultiplier
        return
    end
    
    espSizeMultiplier = tempSizeMultiplier
    
    for model, _ in pairs(espHighlights) do
        if model and model.Parent then
            resetScaleESP(model)
            applyScaleESP(model)
        end
    end
end

local ESPTab = MenuSection:Tab({
    Title = "ESP",
    Icon = "user-round-search",
    Opened = true,
})

local ESPToggleSection = ESPTab:Section({
    Title = "Player ESP",
    Icon = "eye",
    Opened = true
})

local ESPToggle = ESPToggleSection:Toggle({
    Title = "Enable ESP",
    Desc = "Makes Every Player Visible!",
    Value = false,
    Callback = function(state)
        espEnabled = state
        if state then
            applyESPToAll()
        else
            removeAllESP()
        end
    end
})

local PlayersESPColor = ESPTab:Section({
    Title = "ESP Colors",
    Icon = "palette",
    Opened = true
})

local ColorDropdown = PlayersESPColor:Dropdown({
    Title = "ESP Color",
    Desc = "Choose a color for player ESP!",
    Values = { "Red", "Blue", "Green", "Yellow", "Black", "Purple", "Orange", "Cyan", "White" },
    Value = "Green",
    Callback = function(option)
        selectedESPColor = option
    end
})

PlayersESPColor:Button({
    Title = "Set Color",
    Desc = "Apply the selected color to ESP",
    Callback = function()
        currentESPColor = colorMap[selectedESPColor]
        updateESPColors()
    end
})

local PlayerTurnESPSection = ESPTab:Section({
    Title = "Player Turn ESP",
    Icon = "hash",
    Opened = true
})

PlayerTurnESPSection:Toggle({
    Title = "Enable Turn ESP",
    Desc = "Shows player shooting turn above their head!",
    Value = false,
    Callback = function(state)
        turnESPEnabled = state
        if state then
            enableTurnESP()
        else
            removeAllTurnESP()
        end
    end
})

local BeamESPSection = ESPTab:Section({
    Title = "Beam ESP",
    Icon = "zap",
    Opened = true
})

local BeamESPToggle = BeamESPSection:Toggle({
    Title = "Enable Beam ESP",
    Desc = "Shows player aim beams!",
    Value = false,
    Callback = function(state)
        beamESPEnabled = state
        if state then
            enableAllBeams()
            monitorForNewBeams()
        else
            removeAllBeamESP()
        end
    end
})

local BombsESPSection = ESPTab:Section({
    Title = "Bombs ESP",
    Icon = "bomb",
    Opened = true
})

local BombsESPToggle = BombsESPSection:Toggle({
    Title = "Enable Bombs ESP",
    Desc = "Makes Bomb and Nuke visible!",
    Value = false,
    Callback = function(state)
        bombsESPEnabled = state
        if state then
            enableBombsESP()
        else
            removeAllBombsESP()
        end
    end
})

local PlayersESPSize = ESPTab:Section({
    Title = "ESP Size",
    Icon = "maximize-2",
    Opened = true
})

local SizeSlider = PlayersESPSize:Slider({
    Title = "ESP Size",
    Desc = "Adjust the size of player models (1x - 3x)",
    Step = 0.1,
    Value = {
        Min = 1,
        Max = 3,
        Default = 1,
    },
    Callback = function(value)
        tempSizeMultiplier = value
    end
})

PlayersESPSize:Button({
    Title = "Set Size",
    Desc = "Apply the selected size to ESP",
    Callback = function()
        updateESPSize()
    end
})

local ESPReset = ESPTab:Section({
    Title = "Reset ESP",
    Icon = "rotate-ccw",
    Opened = true
})

ESPReset:Button({
    Title = "Full Reset",
    Desc = "Turn off ESP and reset everything",
    Callback = function()
        espEnabled = false
        beamESPEnabled = false
        bombsESPEnabled = false
        turnESPEnabled = false
        ESPToggle:Set(false)
        BeamESPToggle:Set(false)
        BombsESPToggle:Set(false)
        removeAllESP()
        removeAllBeamESP()
        removeAllBombsESP()
        removeAllTurnESP()
        
        espSizeMultiplier = 1
        tempSizeMultiplier = 1
        currentESPColor = Color3.fromRGB(0, 255, 0)
        selectedESPColor = "Green"
        
        SizeSlider:Set(1)
        ColorDropdown:Select("Green")
    end
})

local AutoFarmTab = MenuSection:Tab({
    Title = "Auto Farm",
    Icon = "coins",
    Opened = true,
})

local autoFarmCashEnabled = false

local function autoFarmCash()
    while autoFarmCashEnabled do
        local trophy = workspace:FindFirstChild("Trophy")
        if trophy then
            local touchInterest = trophy:FindFirstChild("TouchInterest")
            if touchInterest then
                local player = game.Players.LocalPlayer
                if player and player.Character then
                    local humanoidRootPart = player.Character:FindFirstChild("HumanoidRootPart")
                    if humanoidRootPart then
                        firetouchinterest(humanoidRootPart, trophy, 0)
                        task.wait(0.1)
                        firetouchinterest(humanoidRootPart, trophy, 1)
                    end
                end
            end
        end
        task.wait(10)
    end
end

local function enableAutoFarmCash()
    task.spawn(autoFarmCash)
end

local function disableAutoFarmCash()
end

local AutoFarmCashSection = AutoFarmTab:Section({
    Title = "Auto Farm Cash",
    Icon = "dollar-sign",
    Opened = true
})

AutoFarmCashSection:Toggle({
    Title = "Enable Auto Farm Cash",
    Desc = "Automatically Collects Trophy For You!",
    Value = false,
    Callback = function(state)
        autoFarmCashEnabled = state
        if state then
            enableAutoFarmCash()
        else
            disableAutoFarmCash()
        end
    end
})

local CombatTab = MenuSection:Tab({
    Title = "Combat",
    Icon = "swords",
    Opened = true,
})

local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")

local autoAvoidEnabled = false
local avoidConnection = nil
local trackedBeams = {}

local function isInArena()
    local jogadoresVivos = workspace:FindFirstChild("jogadoresVivos")
    if not jogadoresVivos then return false end
    local playerInArena = jogadoresVivos:FindFirstChild(LocalPlayer.Name)
    return playerInArena ~= nil
end

local function shouldAvoid()
    local success, result = pcall(function()
        local timerLabel = LocalPlayer.PlayerGui:FindFirstChild("TimerGui")
        if timerLabel then
            timerLabel = timerLabel:FindFirstChild("TimerFrame")
            if timerLabel then
                timerLabel = timerLabel:FindFirstChild("TimerLabel")
                if timerLabel then
                    local text = timerLabel.Text
                    if text:match("Players will appear in:") then
                        local number = tonumber(text:match("%d+"))
                        if number and number >= 0 and number <= 15 then
                            return true
                        end
                    end
                end
            end
        end
        return false
    end)
    return success and result
end

local function getRandomSafePosition()
    local chao = workspace:FindFirstChild("chao")
    if not chao or not chao:IsA("BasePart") then
        return nil
    end
    
    local arenaSize = chao.Size
    local arenaPosition = chao.Position
    
    if arenaSize.X < 5 or arenaSize.Z < 5 then
        return nil
    end
    
    local margin = math.min(2, arenaSize.X * 0.1, arenaSize.Z * 0.1)
    local maxX = math.max(2, arenaSize.X/2 - margin)
    local maxZ = math.max(2, arenaSize.Z/2 - margin)
    
    local randomX = arenaPosition.X + math.random(-maxX, maxX)
    local randomZ = arenaPosition.Z + math.random(-maxZ, maxZ)
    local y = arenaPosition.Y + (arenaSize.Y/2) + 3
    
    return Vector3.new(randomX, y, randomZ)
end

local function isPositionSafe(position, minDistance)
    minDistance = minDistance or 15
    
    for _, obj in pairs(workspace:GetDescendants()) do
        if obj:IsA("Beam") and not obj.Enabled then
            local beamPos = nil
            local attachment0 = obj:FindFirstChild("Attachment0")
            
            if attachment0 then
                beamPos = attachment0.WorldPosition
            end
            
            if beamPos then
                local distance = (position - beamPos).Magnitude
                
                if distance < minDistance then
                    return false
                end
            end
        end
    end
    
    return true
end

local function teleportToSafety()
    if not autoAvoidEnabled then return end
    if not LocalPlayer.Character then return end
    
    local humanoidRootPart = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then return end
    
    for i = 1, 10 do
        local safePosition = getRandomSafePosition()
        if safePosition and isPositionSafe(safePosition, 15) then
            humanoidRootPart.CFrame = CFrame.new(safePosition)
            return true
        end
    end
    
    local anyPosition = getRandomSafePosition()
    if anyPosition then
        humanoidRootPart.CFrame = CFrame.new(anyPosition)
    end
    
    return false
end

local function isInDanger()
    if not LocalPlayer.Character then 
        return false 
    end
    local humanoidRootPart = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then 
        return false 
    end
    
    local playerPos = humanoidRootPart.Position
    local dangerDistance = 30
    
    for _, obj in pairs(workspace:GetDescendants()) do
        if obj:IsA("Beam") then
            if not obj.Enabled then
                local beamPos = nil
                local attachment0 = obj:FindFirstChild("Attachment0")
                local attachment1 = obj:FindFirstChild("Attachment1")
                
                if attachment0 then
                    beamPos = attachment0.WorldPosition
                elseif attachment1 then
                    beamPos = attachment1.WorldPosition
                elseif obj.Parent and obj.Parent:IsA("BasePart") then
                    beamPos = obj.Parent.Position
                end
                
                if beamPos then
                    local distance = (playerPos - beamPos).Magnitude
                    
                    if distance < dangerDistance then
                        return true, obj
                    end
                end
            end
        end
    end
    
    return false
end

local function monitorBeams()
    if not autoAvoidEnabled then 
        return 
    end
    
    if not isInArena() then
        return
    end
    
    local shouldAvoidNow = shouldAvoid()
    
    if not shouldAvoidNow then 
        return 
    end
    
    local inDanger, dangerousBeam = isInDanger()
    
    if inDanger then
        if not trackedBeams[dangerousBeam] then
            trackedBeams[dangerousBeam] = true
            teleportToSafety()
            
            task.delay(0.2, function()
                trackedBeams[dangerousBeam] = nil
            end)
        end
    end
end

local function enableAutoAvoid()
    if avoidConnection then
        avoidConnection:Disconnect()
    end
    
    avoidConnection = RunService.Heartbeat:Connect(function()
        monitorBeams()
    end)
end

local function disableAutoAvoid()
    if avoidConnection then
        avoidConnection:Disconnect()
        avoidConnection = nil
    end
    trackedBeams = {}
end

local AutoAvoidSection = CombatTab:Section({
    Title = "Auto Avoid",
    Icon = "shield",
    Opened = true
})

AutoAvoidSection:Toggle({
    Title = "Enable Auto Avoid",
    Desc = "Automatically dodges other players lasers/beams!",
    Value = false,
    Callback = function(state)
        autoAvoidEnabled = state
        if state then
            enableAutoAvoid()
        else
            disableAutoAvoid()
        end
    end
})

local AimbotSection = CombatTab:Section({
    Title = "Aimbot",
    Icon = "crosshair",
    Opened = true
})

local aimbotEnabled = false
local aimbotConnection = nil
local targetPlayer = nil

local function getClosestEnemy()
    if not LocalPlayer.Character then return nil end
    local humanoidRootPart = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then return nil end
    
    local closestPlayer = nil
    local shortestDistance = math.huge
    
    local jogadoresVivos = workspace:FindFirstChild("jogadoresVivos")
    if not jogadoresVivos then return nil end
    
    for _, playerValue in pairs(jogadoresVivos:GetChildren()) do
        if playerValue.Name ~= LocalPlayer.Name then
            local playerModel = workspace:FindFirstChild(playerValue.Name)
            if playerModel and playerModel:IsA("Model") then
                local targetRoot = playerModel:FindFirstChild("HumanoidRootPart")
                if targetRoot then
                    local distance = (humanoidRootPart.Position - targetRoot.Position).Magnitude
                    if distance < shortestDistance then
                        shortestDistance = distance
                        closestPlayer = playerModel
                    end
                end
            end
        end
    end
    
    return closestPlayer
end

local function aimAtTarget()
    if not aimbotEnabled then return end
    if not isInArena() then return end
    if not LocalPlayer.Character then return end
    
    local humanoidRootPart = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then return end
    
    targetPlayer = getClosestEnemy()
    
    if not targetPlayer then return end
    
    local targetHead = targetPlayer:FindFirstChild("Head")
    local targetRoot = targetPlayer:FindFirstChild("HumanoidRootPart")
    
    if not targetHead and not targetRoot then 
        targetPlayer = nil
        return 
    end
    
    local targetPosition
    if targetHead then
        targetPosition = targetHead.Position
    elseif targetRoot then
        targetPosition = targetRoot.Position + Vector3.new(0, 1.5, 0)
    end
    
    humanoidRootPart.CFrame = CFrame.new(humanoidRootPart.Position, Vector3.new(targetPosition.X, humanoidRootPart.Position.Y, targetPosition.Z))
    
    for _, skinModel in pairs(LocalPlayer.Character:GetChildren()) do
        if skinModel:IsA("Model") and skinModel.Name:match("^Skin_") then
            local ponto = skinModel:FindFirstChild("ponto")
            if ponto then
                local beam = ponto:FindFirstChildOfClass("Beam")
                if beam then
                    local attachment0 = beam:FindFirstChild("Attachment0")
                    local attachment1 = beam:FindFirstChild("Attachment1")
                    
                    if attachment0 and attachment1 then
                        attachment1.WorldPosition = targetPosition
                    end
                end
                break
            end
        end
    end
end

local function enableAimbot()
    if aimbotConnection then
        aimbotConnection:Disconnect()
    end
    
    aimbotConnection = RunService.Heartbeat:Connect(function()
        aimAtTarget()
    end)
end

local function disableAimbot()
    if aimbotConnection then
        aimbotConnection:Disconnect()
        aimbotConnection = nil
    end
    targetPlayer = nil
end

AimbotSection:Toggle({
    Title = "Enable Aimbot",
    Desc = "Makes your character face and beam lock onto closest enemy(MAKE SURE SHIFTLOCK IS OFF!)",
    Value = false,
    Callback = function(state)
        aimbotEnabled = state
        if state then
            enableAimbot()
        else
            disableAimbot()
        end
    end
})

local AntiFist = CombatTab:Section({
    Title = "Anti-Fist",
    Icon = "hand",
    Opened = true
})

AntiFist:Button({
    Title = "Anti-Fist (No Knockback)",
    Locked = false,
    Callback = function()
        local RunService = game:GetService("RunService")
        local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
        local Humanoid = Character:WaitForChild("Humanoid")
        local RootPart = Character:WaitForChild("HumanoidRootPart")

        Humanoid:SetStateEnabled(Enum.HumanoidStateType.Ragdoll, false)
        Humanoid:SetStateEnabled(Enum.HumanoidStateType.FallingDown, false)
        Humanoid:SetStateEnabled(Enum.HumanoidStateType.PlatformStanding, false)

        RunService.Heartbeat:Connect(function()
            if Humanoid:GetState() == Enum.HumanoidStateType.Ragdoll or
               Humanoid:GetState() == Enum.HumanoidStateType.FallingDown or
               Humanoid:GetState() == Enum.HumanoidStateType.PlatformStanding then
                Humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
                Humanoid:ChangeState(Enum.HumanoidStateType.Running)
            end

            for _, v in pairs(RootPart:GetChildren()) do
                if v:IsA("BodyVelocity") or v:IsA("BodyForce") or v:IsA("LinearVelocity") or v:IsA("VectorForce") then
                    v:Destroy()
                end
            end

            Humanoid.Health = Humanoid.Health + 0.1
        end)

        LocalPlayer.CharacterAdded:Connect(function(newChar)
            Character = newChar
            Humanoid = newChar:WaitForChild("Humanoid")
            RootPart = newChar:WaitForChild("HumanoidRootPart")

            Humanoid:SetStateEnabled(Enum.HumanoidStateType.Ragdoll, false)
            Humanoid:SetStateEnabled(Enum.HumanoidStateType.FallingDown, false)
            Humanoid:SetStateEnabled(Enum.HumanoidStateType.PlatformStanding, false)
        end)

        game:GetService("StarterGui"):SetCore("SendNotification", {
            Title = "Anti-Fist",
            Text = "Activated - No more knockback or ragdoll!",
            Duration = 3
        })
    end
})

local PlayerTab = MenuSection:Tab({
    Title = "Player",
    Icon = "user",
    Locked = false,
})

local UserInputService = game:GetService("UserInputService")

getgenv().walkSpeed = 16
getgenv().jumpPower = 50
getgenv().flyEnabled = false
getgenv().noClipEnabled = false
getgenv().InfJumpEnabled = false
getgenv().antiAfkEnabled = false

local flyConnection = nil
local noClipConnection = nil
local antiAfkConnection = nil
local jumping = false

local function setWalkSpeed(speed)
    if LocalPlayer.Character then
        local humanoid = LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            humanoid.WalkSpeed = speed
        end
    end
end

local function setJumpPower(power)
    if LocalPlayer.Character then
        local humanoid = LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            humanoid.JumpPower = power
        end
    end
end

LocalPlayer.CharacterAdded:Connect(function()
    task.wait(0.5)
    setWalkSpeed(getgenv().walkSpeed)
    setJumpPower(getgenv().jumpPower)
end)

local function startFlying()
    if flyConnection then
        flyConnection:Disconnect()
    end
    
    local character = LocalPlayer.Character
    if not character then return end
    
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then return end
    
    local bodyVelocity = Instance.new("BodyVelocity")
    bodyVelocity.Velocity = Vector3.new(0, 0, 0)
    bodyVelocity.MaxForce = Vector3.new(100000, 100000, 100000)
    bodyVelocity.Parent = humanoidRootPart
    
    local bodyGyro = Instance.new("BodyGyro")
    bodyGyro.MaxTorque = Vector3.new(100000, 100000, 100000)
    bodyGyro.CFrame = humanoidRootPart.CFrame
    bodyGyro.Parent = humanoidRootPart
    
    local camera = workspace.CurrentCamera
    local flySpeed = 50
    
    flyConnection = RunService.Heartbeat:Connect(function()
        if not getgenv().flyEnabled then
            if bodyVelocity then bodyVelocity:Destroy() end
            if bodyGyro then bodyGyro:Destroy() end
            if flyConnection then flyConnection:Disconnect() end
            return
        end
        
        if character and humanoidRootPart then
            local moveDirection = Vector3.new(0, 0, 0)
            
            if UserInputService:IsKeyDown(Enum.KeyCode.W) then
                moveDirection = moveDirection + (camera.CFrame.LookVector * flySpeed)
            end
            if UserInputService:IsKeyDown(Enum.KeyCode.S) then
                moveDirection = moveDirection - (camera.CFrame.LookVector * flySpeed)
            end
            if UserInputService:IsKeyDown(Enum.KeyCode.A) then
                moveDirection = moveDirection - (camera.CFrame.RightVector * flySpeed)
            end
            if UserInputService:IsKeyDown(Enum.KeyCode.D) then
                moveDirection = moveDirection + (camera.CFrame.RightVector * flySpeed)
            end
            if UserInputService:IsKeyDown(Enum.KeyCode.Space) then
                moveDirection = moveDirection + Vector3.new(0, flySpeed, 0)
            end
            if UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) then
                moveDirection = moveDirection - Vector3.new(0, flySpeed, 0)
            end
            
            bodyVelocity.Velocity = moveDirection
            bodyGyro.CFrame = camera.CFrame
        end
    end)
end

local function stopFlying()
    getgenv().flyEnabled = false
    if flyConnection then
        flyConnection:Disconnect()
        flyConnection = nil
    end
    
    if LocalPlayer.Character then
        local humanoidRootPart = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        if humanoidRootPart then
            for _, obj in pairs(humanoidRootPart:GetChildren()) do
                if obj:IsA("BodyVelocity") or obj:IsA("BodyGyro") then
                    obj:Destroy()
                end
            end
        end
    end
end

local function startNoClip()
    if noClipConnection then
        noClipConnection:Disconnect()
    end
    
    noClipConnection = RunService.Stepped:Connect(function()
        if not getgenv().noClipEnabled then
            if noClipConnection then
                noClipConnection:Disconnect()
            end
            return
        end
        
        if LocalPlayer.Character then
            for _, part in pairs(LocalPlayer.Character:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = false
                end
            end
        end
    end)
end

local function stopNoClip()
    getgenv().noClipEnabled = false
    if noClipConnection then
        noClipConnection:Disconnect()
        noClipConnection = nil
    end
    
    if LocalPlayer.Character then
        for _, part in pairs(LocalPlayer.Character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = true
            end
        end
    end
end

local function startAntiAfk()
    if antiAfkConnection then
        antiAfkConnection:Disconnect()
    end
    
    local vu = game:GetService("VirtualUser")
    antiAfkConnection = LocalPlayer.Idled:Connect(function()
        vu:Button2Down(Vector2.new(0,0),workspace.CurrentCamera.CFrame)
        task.wait(1)
        vu:Button2Up(Vector2.new(0,0),workspace.CurrentCamera.CFrame)
    end)
end

local function stopAntiAfk()
    getgenv().antiAfkEnabled = false
    if antiAfkConnection then
        antiAfkConnection:Disconnect()
        antiAfkConnection = nil
    end
end

local Speedandjump = PlayerTab:Section({
    Title = "Speed and Jump",
    Icon = "arrow-big-up-dash",
    Opened = true
})

Speedandjump:Slider({
    Title = "Speed",
    Desc = "Adjust your walk speed",
    Step = 1,
    Value = {
        Min = 1,
        Max = 100,
        Default = 16,
    },
    Callback = function(value)
        getgenv().walkSpeed = value
        setWalkSpeed(value)
    end
})

Speedandjump:Slider({
    Title = "JumpPower",
    Desc = "Adjust your jump power",
    Step = 1,
    Value = {
        Min = 1,
        Max = 200,
        Default = 50,
    },
    Callback = function(value)
        getgenv().jumpPower = value
        setJumpPower(value)
    end
})

local othersplayershacks = PlayerTab:Section({
    Title = "Others",
    Icon = "sparkle",
    Opened = true
})

othersplayershacks:Toggle({
    Title = "Fly",
    Desc = "Enables flying! (PC: WASD, Space/Ctrl for up/down)",
    Default = false,
    Callback = function(state)
        getgenv().flyEnabled = state
        
        if state then
            startFlying()
            WindUI:Notify({
                Title = "Fly Enabled",
                Content = "You can now fly! WASD to move, Space/Ctrl for up/down.",
                Duration = 5,
                Icon = "plane"
            })
        else
            stopFlying()
        end
    end
})

othersplayershacks:Toggle({
    Title = "NoClip",
    Desc = "Allows you to pass through walls!",
    Default = false,
    Callback = function(state)
        getgenv().noClipEnabled = state
        
        if state then
            startNoClip()
            WindUI:Notify({
                Title = "NoClip Enabled",
                Content = "You can now pass through walls!",
                Duration = 5,
                Icon = "ghost"
            })
        else
            stopNoClip()
            WindUI:Notify({
                Title = "NoClip Disabled",
                Content = "Collisions restored.",
                Duration = 5,
                Icon = "ghost"
            })
        end
    end
})

othersplayershacks:Toggle({
    Title = "Infinite Jump",
    Desc = "Hold space to jump infinitely",
    Default = false,
    Callback = function(state)
        getgenv().InfJumpEnabled = state
    end
})

othersplayershacks:Toggle({
    Title = "Anti-AFK",
    Desc = "Prevents you from being kicked for inactivity!",
    Default = false,
    Callback = function(state)
        getgenv().antiAfkEnabled = state
        
        if state then
            startAntiAfk()
            WindUI:Notify({
                Title = "Anti-AFK Enabled",
                Content = "You will no longer be kicked for inactivity!",
                Duration = 5,
                Icon = "clock"
            })
        else
            stopAntiAfk()
            WindUI:Notify({
                Title = "Anti-AFK Disabled",
                Content = "Anti-AFK system stopped.",
                Duration = 5,
                Icon = "clock"
            })
        end
    end
})

UserInputService.InputBegan:Connect(function(input, gp)
    if gp then return end
    if input.KeyCode == Enum.KeyCode.Space or input.UserInputType == Enum.UserInputType.Touch then
        jumping = true
    end
end)

UserInputService.InputEnded:Connect(function(input)
    if input.KeyCode == Enum.KeyCode.Space or input.UserInputType == Enum.UserInputType.Touch then
        jumping = false
    end
end)

task.spawn(function()
    while task.wait(0.1) do
        if getgenv().InfJumpEnabled and jumping then
            local character = LocalPlayer.Character
            if character then
                local humanoid = character:FindFirstChildOfClass("Humanoid")
                if humanoid and humanoid:GetState() ~= Enum.HumanoidStateType.Dead then
                    humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
                end
            end
        end
    end
end)
